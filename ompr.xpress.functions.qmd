---
title: "ompr.xpress package functions"
author: "Brandon Dahl"
format: html
editor: visual
---

1.  pull out all list names
2.  compile list of all string, double, and integer control parameters
3.  check if any names are in control parameters
4.  compile parameter types
5.  loop through all parameter types and set parameter

## Import Libraries

```{r}

# Import Libraries
library(ompr)
library(xpress)

# Clear Out Variables
rm(list = ls())

```

## Test Optimization Problem

```{r}
#| include: false 

# Set Static Variables
ndays <- 1
nhours <- 24
per <- ndays * nhours

# Set Storage Values
in_storage <- 10
hourly_inflow <- 35
hourly_ifr <- 1
storage_max <- 300
storage_min <- 0

# Set PH Parameters
gen_segs <- 3
nrz_min <- 10
nrz_max <- 18
ph_pmin <- 6
ph_pmax <- 32
ph_starts <- 2

# Create Reservoir Parameters
res_parameters <- data.frame(HOUR = 1:per,
                             RES_MIN = rep(storage_min, per),
                             RES_MAX = rep(storage_max, per),
                             INFLOW = rep(hourly_inflow, per),
                             IFR = rep(hourly_ifr, per))

# Create Unit Parameters
unit_parameters <- data.frame(HOUR = 1:per,
                              MIN_LOAD = rep(6,per),
                              PMIN = rep(0,per),
                              PMAX = rep(32,per))

# PH WD Segments
unit_wd <- data.frame(MW_SEG = c(17.86, 11.14, 4),
                      SLOPE = c(2.26, 2.44, 2.71))

# Leakage
leakage <- 7.21

# Create Price Forecast
price <- data.frame(HOUR = 1:24,
                    PRICE = c(62.29,58.00,55.70,55.46,55.70,
                              56.83,55.46,52.43,47.69,46.20,
                              47.78,49.29,49.88,52.62,54.64,
                              54.82,59.85,62.95,78.40,108.64,
                              87.62,72.74,71.54,65.69))

#_________________________________________________________________________________________________________
#### Build Optimization Model ####

# Create Model
model <- ompr::MIPModel()

#_______________________________________________________
##### Model - Create Decision Variables ####

# Create Decision Variables
model <- model |>
  # Create Gen Variables
  add_variable(gen[p], type = 'continuous', p = 1:per, lb = 0) |>
  add_variable(flow[p], type = 'continuous', p = 1:per, lb = 0) |>
  # Create Semi-Continuous Variable
  add_variable(gen_semcont_bin[p], type = 'binary', p=1:per) |>
  # Create Piecewise Gen Variables
  add_variable(gen_seg_enf[p,g], type = 'binary', p = 1:per, g = 1:gen_segs, lb = 0) |>
  add_variable(gen_segs[p,g], type = 'continuous', p = 1:per, g = 1:gen_segs, lb = 0) |>
  # Create No-Run Zone Variables
  add_variable(nrz_bin_one[p], type = 'binary', p = 1:per) |>
  add_variable(nrz_bin_two[p], type = 'binary', p = 1:per) |>
  add_variable(gen_stage_one[p], type = 'continuous', p = 1:per, lb = 0) |>
  add_variable(gen_stage_two[p], type = 'continuous', p = 1:per, lb = 0) |>
  # Create Reservoir Variables
  add_variable(storage[p], type = 'continuous', p = 1:per, lb = 0)

#_______________________________________________________
##### Model - Create Constraints ####

# Create Model Constraints
model <- model |>
  # Add Generation Constraints
  add_constraint(gen[p] <= unit_parameters$PMAX[p], p = 1:per) |>
  add_constraint(gen[p] >= unit_parameters$PMIN[p] , p = 1:per, lb = 0) |>
  # Add Semi-Continous Constraints
  add_constraint(gen[p] <= gen_semcont_bin[p]*unit_parameters$PMAX[p], p = 1:per) |>
  add_constraint(gen[p] >= gen_semcont_bin[p]*unit_parameters$MIN_LOAD[p], p = 1:per) |>
  # Add Piecewise Generation Constraints
  add_constraint(sum_over(gen_segs[p,g], g = 1:nrow(unit_wd)) == gen[p], p = 1:per) |>
  add_constraint(gen_segs[p,g] <= unit_wd$MW_SEG[g]*gen_seg_enf[p,g], p = 1:per, g = 1:3) |>
  add_constraint(gen_seg_enf[p,g] >= gen_seg_enf[p,g+1], p = 1:per, g = 1:(3-1)) |>
  add_constraint(gen_segs[p,g] >= unit_wd$MW_SEG[g]*gen_seg_enf[p,g+1], p = 1:per, g = 1:(3-1)) |>
  add_constraint(gen[p] >= gen_seg_enf[p,1]*1, p = 1:per) |>
  # Add No-Run Zone Constraints
  add_constraint(gen_stage_one[p] <= (nrz_min - ph_pmin)*nrz_bin_one[p], p = 1:per) |>
  add_constraint(gen_stage_two[p] <= (unit_parameters$PMAX[p] - nrz_max)*nrz_bin_two[p], p = 1:per) |>
  add_constraint(nrz_bin_one[p] >= nrz_bin_two[p], p = 1:per) |>
  add_constraint(gen_stage_one[p] >= (nrz_min - ph_pmin)*nrz_bin_two[p], p = 1:per) |>
  # Apply NRZ Constraint
  add_constraint(gen[p] == (ph_pmin*nrz_bin_one[p] + gen_stage_one[p] + ((nrz_max - nrz_min)*nrz_bin_two[p] + gen_stage_two[p])),
                 p = 1:per) |>
  # Create Flow Equations
  add_constraint((sum_over(gen_segs[p,g]*unit_wd$SLOPE[g], g = 1:3) + leakage*gen_seg_enf[p,1]) == flow[p], p = 1:per) |>
  # Create Reservoir Storage Constraints
  add_constraint(storage[p] == in_storage + hourly_inflow - hourly_ifr - flow[p], p = 1) |>
  add_constraint(storage[p] == storage[p-1] + hourly_inflow - hourly_ifr - flow[p], p = 2:per) |>
  add_constraint(storage[p] >= res_parameters$RES_MIN[p], p = 1:per) |>
  add_constraint(storage[p] <= res_parameters$RES_MAX[p], p = 1:per)

#_______________________________________________________
##### Model - Create Objective Function ####

  # Create Objective Function
model <- model |>
  set_objective(sum_over(gen[p]*price$PRICE[p], p = 1:per))

```

#### Constraint Sense Conversion

```{r}

# Create Row Type Conversion
xpress_sense_conversion <- function(sense){

  # Create Conversion Library
  conversion_list <- list("<=" = "L",
                          "==" = "E",
                          ">=" = "G")

  # Convert Sense
  if (sense %in% names(conversion_list)){

    # Convert Sybol
    temp_sense <- conversion_list[[sense]]

    # Close Function
    return(temp_sense)

  } else {

    # Notify user
    paste0("The sense type ", sense, 
           ' is not a valid option. Check Xpress/OMPR documentation for assitance') |> 
      print()

  }
  
}

```

#### Column Type Conversion

```{r}

# Create Column Type Conversion
xpress_col_type_conversion <- function(col_type){

  # Create Conversion Library
  # Semi-Continuous not available in OMPR package, but included regardless
  conversion_list <- list('continuous' = 'C',
                          'binary' = 'B',
                          'integer' = 'I',
                          'semi-continuous' = 'S')

  # Convert Column Type
  if (col_type %in% names(conversion_list)){

    # Convert
    temp_col_type <- conversion_list[[col_type]]

    # Close Function
    return(temp_col_type)

  } else {

    # Notify user
    print(paste0('Column type ', col_type, 
                 '  does not exist. Explore OMPR/Xpress documentation for help troubleshooting'))

  }

}

```

#### Column Type Fill Function

```{r}

# Fill In Columns With Conversion
xpress_col_type_fill <- function(x, conversion_list){

  # Extract Data
  key <- sub(pattern = "\\[.*", "", x)

  # Check List
   if (key %in% names(conversion_list)){

     # Get Type
     temp_type <- conversion_list[[key]]
     return(temp_type)
   }

  # Print
  paste0('The column type ', key, 
         ' is not a valid option. Please explore Xpress/OMPR documentation for assistance') |> 
    print()

}

```

Extract All Parameters

```{r}

# 
xpress_extract_control_params <- function(x){
  
  # Get list of all control params
  xpress_control_params <- c(xpress::xprs_getintcontrols(),
                             xpress::xprs_getdoublecontrols(),
                             xpress::xprs_getstringcontrols())
  
  # 
  
  
  
}


```

Apply All Control Parameters

```{r}

xpress_apply_control_params <- function(x){
  
  # Get list of all control params and their type
  xpress_control_params <- c(names(xpress::xprs_getintcontrols()) = 'integer',
                             names(xpress::xprs_getdoublecontrols()) = 'double',
                             names(xpress::xprs_getstringcontrols()) = 'string')
  
  # Filter Control List
  filtered_x <- x[names(x) %in% names(xpress_control_params)]
  
  # Classify Controls
  for (r in 1:length(filtered_x)){
    
    print(filtered_x[r] |> names())
    
  }
  
  
  
  
}

```

### Optimize Function

```{r}

xpress_optimizer <- function(control = list(problem_name = 'Xpress Problem'), ...){

  # Create Model Run Function
  function(model){
    
    test_control <<- c(control,...)
  
    # Extract values from Model using OMPR functions
    # obj <- ompr::objective_function(model)
    # constraints <- ompr::extract_constraints(model)
    # var_names <- ompr::variable_keys(model)
    # upper_bounds <- ompr::variable_bounds(model)[['upper']]
    # lower_bounds <- ompr::variable_bounds(model)[['lower']]
    # obj_sense <- switch(model$objective$sense, 'max' = -1L, 'min' = 1L, 
    #                     stop('Objective sense not valid'))
    # 
    # # Create List For Xpress Problem Data
    # problemdata <- list()
    # 
    # # Create Objective Function
    # problemdata$objcoef <- obj$solution |> as.numeric()
    # 
    # # Get Row Coefficients
    # problemdata$A <- constraints$matrix
    #  
    # # Get Variable Types
    # problemdata$columntypes <- (lapply(model$variable_types, FUN = xpress_col_type_conversion) |>
    #                                lapply(var_names, FUN = xpress_col_type_fill, conversion_list = _) |>
    #                                 unlist())
    #  
    # # Get problemdata Types
    # problemdata$rowtype <- (lapply(X = constraints$sense, FUN = xpress_sense_conversion) |> unlist())
    #  
    # # Get Right-Hand Side
    # problemdata$rhs <- constraints$rhs |> as.numeric()
    #  
    # # specify lower bounds and upper bounds for the columns
    # problemdata$lb <- lower_bounds
    # problemdata$ub <- upper_bounds
    #  
    # # Add Variable Names
    # problemdata$colname <- var_names
    # 
    # # Name Problem
    # problemdata$probname <- control$problem_name 
    # 
    # # Load Problem Into Xpress Prob Object
    # p <- xprs_loadproblemdata(problemdata = problemdata)
    
    # Apply All Control Parameters

  }
  


}

```
