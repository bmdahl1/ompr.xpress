---
title: "ompr.xpress package functions"
author: "Brandon Dahl"
format: html
editor: visual
---

## Import Libraries

```{r}

# Import Libraries
library(ompr)
library(xpress)

# Clear Out Variables
rm(list = ls())

```

## Test Optimization Problem

```{r}
#| include: false 

# Set Static Variables
ndays <- 1
nhours <- 24
per <- ndays * nhours

# Set Storage Values
in_storage <- 10
hourly_inflow <- 35
hourly_ifr <- 1
storage_max <- 300
storage_min <- 0

# Set PH Parameters
gen_segs <- 3
nrz_min <- 10
nrz_max <- 18
ph_pmin <- 6
ph_pmax <- 32
ph_starts <- 2

# Create Reservoir Parameters
res_parameters <- data.frame(HOUR = 1:per,
                             RES_MIN = rep(storage_min, per),
                             RES_MAX = rep(storage_max, per),
                             INFLOW = rep(hourly_inflow, per),
                             IFR = rep(hourly_ifr, per))

# Create Unit Parameters
unit_parameters <- data.frame(HOUR = 1:per,
                              MIN_LOAD = rep(6,per),
                              PMIN = rep(0,per),
                              PMAX = rep(32,per))

# PH WD Segments
unit_wd <- data.frame(MW_SEG = c(17.86, 11.14, 4),
                      SLOPE = c(2.26, 2.44, 2.71))

# Leakage
leakage <- 7.21

# Create Price Forecast
price <- data.frame(HOUR = 1:24,
                    PRICE = c(62.29,58.00,55.70,55.46,55.70,
                              56.83,55.46,52.43,47.69,46.20,
                              47.78,49.29,49.88,52.62,54.64,
                              54.82,59.85,62.95,78.40,108.64,
                              87.62,72.74,71.54,65.69))

#_________________________________________________________________________________________________________
#### Build Optimization Model ####

# Create Model
model <- ompr::MIPModel()

#_______________________________________________________
##### Model - Create Decision Variables ####

# Create Decision Variables
model <- model |>
  # Create Gen Variables
  add_variable(gen[p], type = 'continuous', p = 1:per, lb = 0) |>
  add_variable(flow[p], type = 'continuous', p = 1:per, lb = 0) |>
  # Create Semi-Continuous Variable
  add_variable(gen_semcont_bin[p], type = 'binary', p=1:per) |>
  # Create Piecewise Gen Variables
  add_variable(gen_seg_enf[p,g], type = 'binary', p = 1:per, g = 1:gen_segs, lb = 0) |>
  add_variable(gen_segs[p,g], type = 'continuous', p = 1:per, g = 1:gen_segs, lb = 0) |>
  # Create No-Run Zone Variables
  add_variable(nrz_bin_one[p], type = 'binary', p = 1:per) |>
  add_variable(nrz_bin_two[p], type = 'binary', p = 1:per) |>
  add_variable(gen_stage_one[p], type = 'continuous', p = 1:per, lb = 0) |>
  add_variable(gen_stage_two[p], type = 'continuous', p = 1:per, lb = 0) |>
  # Create Reservoir Variables
  add_variable(storage[p], type = 'continuous', p = 1:per, lb = 0)

#_______________________________________________________
##### Model - Create Constraints ####

# Create Model Constraints
model <- model |>
  # Add Generation Constraints
  add_constraint(gen[p] <= unit_parameters$PMAX[p], p = 1:per) |>
  add_constraint(gen[p] >= unit_parameters$PMIN[p] , p = 1:per, lb = 0) |>
  # Add Semi-Continous Constraints
  add_constraint(gen[p] <= gen_semcont_bin[p]*unit_parameters$PMAX[p], p = 1:per) |>
  add_constraint(gen[p] >= gen_semcont_bin[p]*unit_parameters$MIN_LOAD[p], p = 1:per) |>
  # Add Piecewise Generation Constraints
  add_constraint(sum_over(gen_segs[p,g], g = 1:nrow(unit_wd)) == gen[p], p = 1:per) |>
  add_constraint(gen_segs[p,g] <= unit_wd$MW_SEG[g]*gen_seg_enf[p,g], p = 1:per, g = 1:3) |>
  add_constraint(gen_seg_enf[p,g] >= gen_seg_enf[p,g+1], p = 1:per, g = 1:(3-1)) |>
  add_constraint(gen_segs[p,g] >= unit_wd$MW_SEG[g]*gen_seg_enf[p,g+1], p = 1:per, g = 1:(3-1)) |>
  add_constraint(gen[p] >= gen_seg_enf[p,1]*1, p = 1:per) |>
  # Add No-Run Zone Constraints
  add_constraint(gen_stage_one[p] <= (nrz_min - ph_pmin)*nrz_bin_one[p], p = 1:per) |>
  add_constraint(gen_stage_two[p] <= (unit_parameters$PMAX[p] - nrz_max)*nrz_bin_two[p], p = 1:per) |>
  add_constraint(nrz_bin_one[p] >= nrz_bin_two[p], p = 1:per) |>
  add_constraint(gen_stage_one[p] >= (nrz_min - ph_pmin)*nrz_bin_two[p], p = 1:per) |>
  # Apply NRZ Constraint
  add_constraint(gen[p] == (ph_pmin*nrz_bin_one[p] + gen_stage_one[p] + ((nrz_max - nrz_min)*nrz_bin_two[p] + gen_stage_two[p])),
                 p = 1:per) |>
  # Create Flow Equations
  add_constraint((sum_over(gen_segs[p,g]*unit_wd$SLOPE[g], g = 1:3) + leakage*gen_seg_enf[p,1]) == flow[p], p = 1:per) |>
  # Create Reservoir Storage Constraints
  add_constraint(storage[p] == in_storage + hourly_inflow - hourly_ifr - flow[p], p = 1) |>
  add_constraint(storage[p] == storage[p-1] + hourly_inflow - hourly_ifr - flow[p], p = 2:per) |>
  add_constraint(storage[p] >= res_parameters$RES_MIN[p], p = 1:per) |>
  add_constraint(storage[p] <= res_parameters$RES_MAX[p], p = 1:per)

#_______________________________________________________
##### Model - Create Objective Function ####

  # Create Objective Function
model <- model |>
  set_objective(sum_over(gen[p]*price$PRICE[p], p = 1:per))

```

#### Extract Status

```{r}

get_xpress_status <- function(x){

  # Calculate Status
  temp_status <- switch(as.character(x),
                 "0" = "XPRS_MIP_NOT_LOADED",
                 "1" = "XPRS_MIP_LP_NOT_OPTIMAL",
                 "2" = "XPRS_MIP_LP_OPTIMAL",
                 "3" = "XPRS_MIP_NO_SOL_FOUND",
                 "4" = "XPRS_MIP_NO_SOL_FOUND",
                 "5" = "XPRS_MIP_INFEAS",
                 "6" = "XPRS_MIP_OPTIMAL",
                 "7" = "XPRS_MIP_UNBOUNDED",
                 "error")

  # Return Status
  return(temp_status)

}


```

#### Constraint Sense Conversion

```{r}

# Create Row Type Conversion
xpress_sense_conversion <- function(sense){

  # Create Conversion Library
  conversion_list <- list("<=" = "L",
                          "==" = "E",
                          ">=" = "G")

  # Convert Sense
  if (sense %in% names(conversion_list)){

    # Convert Sybol
    temp_sense <- conversion_list[[sense]]

    # Close Function
    return(temp_sense)

  } else {

    # Notify user
    paste0("The sense type ", sense, 
           ' is not a valid option. Check Xpress/OMPR documentation for assitance') |> 
      print()

  }
  
}

```

#### Column Type Conversion

```{r}

# Create Column Type Conversion
xpress_col_type_conversion <- function(col_type){

  # Create Conversion Library
  # Semi-Continuous not available in OMPR package, but included regardless
  conversion_list <- list('continuous' = 'C',
                          'binary' = 'B',
                          'integer' = 'I',
                          'semi-continuous' = 'S')

  # Convert Column Type
  if (col_type %in% names(conversion_list)){

    # Convert
    temp_col_type <- conversion_list[[col_type]]

    # Close Function
    return(temp_col_type)

  } else {

    # Notify user
    print(paste0('Column type ', col_type, 
                 '  does not exist. Explore OMPR/Xpress documentation for help troubleshooting'))

  }

}

```

#### Column Type Fill Function

```{r}

# Fill In Columns With Conversion
xpress_col_type_fill <- function(x, conversion_list){

  # Extract Data
  key <- sub(pattern = "\\[.*", "", x)

  # Check List
   if (key %in% names(conversion_list)){

     # Get Type
     temp_type <- conversion_list[[key]]
     return(temp_type)
   }

  # Print
  paste0('The column type ', key, 
         ' is not a valid option. Please explore Xpress/OMPR documentation for assistance') |> 
    print()

}

```

#### Apply All Control Parameters

```{r}

xpress_apply_control_params <- function(prob, control_params){
  
  # Get list of all control params
  xpress_control_params <- c(lapply(X = xprs_getintcontrols(), FUN = \(x) x <- 'integer'),
                             lapply(X = xprs_getdoublecontrols(), FUN = \(x) x <- 'double'),
                             lapply(X = xprs_getstringcontrols(), FUN = \(x) x <- 'string'))
  
  # Filter Control List
  filtered_x <- control_params[names(control_params) %in% names(xpress_control_params)]
  
  # Classify Controls
  for (r in 1:length(filtered_x)){
    
    # Get Control Type, Parameter, Value
    control_type <- xpress_control_params[[filtered_x[r] |> names()]]
    control_parameter <- filtered_x[r] |> names()
    control_value <- filtered_x[r] |> unlist() |> unname()
    
    # Set Parameter
    if (control_type=='integer'){
      
      # Set Integer Parameter
      xpress::setintcontrol(prob = p,
                            control = utils::getFromNamespace(control_parameter, "xpress"),
                            control_value |> as.integer())
      
    } else if(control_type == 'double'){
      
      # Set Double Parameter
      xpress::setdblcontrol(prob = p,
                            control = utils::getFromNamespace(control_parameter, "xpress"),
                            control_value |> as.double())
      
    } else if(control_type == 'string'){
      
      # Set String Parameter
      xpress::setstrcontrol(prob = p,
                            control = utils::getFromNamespace(control_parameter, "xpress"),
                            control_value |> as.character())
      
    }
    
  }
  
}

```

### Optimize Function

```{r}

xpress_optimizer <- function(control = list(problem_name = 'Xpress Problem'), ...){

  # Create Model Run Function
  function(model){
    
    # test_control <<- c(control,...)

    # Extract values from Model using OMPR functions
    obj <- ompr::objective_function(model)
    constraints <- ompr::extract_constraints(model)
    var_names <- ompr::variable_keys(model)
    upper_bounds <- ompr::variable_bounds(model)[['upper']]
    lower_bounds <- ompr::variable_bounds(model)[['lower']]
    obj_sense <- switch(model$objective$sense, 'max' = -1L, 'min' = 1L,
                        stop('Objective sense not valid'))

    # Create List For Xpress Problem Data
    problemdata <- list()

    # Create Objective Function
    problemdata$objcoef <- obj$solution |> as.numeric()

    # Get Row Coefficients
    problemdata$A <- constraints$matrix

    # Get Variable Types
    problemdata$columntypes <- (lapply(model$variable_types, FUN = xpress_col_type_conversion) |>
                                    lapply(var_names, FUN = xpress_col_type_fill, conversion_list = _) |>
                                    unlist())

    # Get problemdata Types
    problemdata$rowtype <- (lapply(X = constraints$sense, FUN = xpress_sense_conversion) |> unlist())

    # Get Right-Hand Side
    problemdata$rhs <- constraints$rhs |> as.numeric()

    # specify lower bounds and upper bounds for the columns
    problemdata$lb <- lower_bounds
    problemdata$ub <- upper_bounds

    # Add Variable Names
    problemdata$colname <- var_names

    # Name Problem
    problemdata$probname <-'test' 
    #control$problem_name

    # Load Problem Into Xpress Prob Object
    p <- xprs_loadproblemdata(problemdata = problemdata)

    # Apply All Control Parameters
    xpress_apply_control_params(prob = p, control_params = control)
    
    # Set Problem Sense
    chgobjsense(p, obj_sense)

    # Run Xpress Optimization
    summary(xpress::xprs_optimize(p))

     # Extract Xpress Results
    xpress_results <- data.frame(Variable = problemdata$colname, Value = xprs_getsolution(p))

    # Get Double Attributes
    dbl_attributes <- lapply(xprs_getdoubleattributes(),
           function(x) { getdblattrib(p, x) })

    # Get Integer Attritubes
    int_attributes <- lapply(xprs_getintattributes(),
                             function(x) { getintattrib(p, x) })

    # Get String Attributes
    str_attributes <- lapply(xprs_getstringattributes(),
                             function(x) { getstringattrib(p, x) })

    # Get Integer Controls
    int_controls <- lapply(xprs_getintcontrols(),
                           function(x) { getintcontrol(p, x) })

    # Get Double Controls
    dbl_controls <- lapply(xprs_getdoublecontrols(),
                           function(x) { getdblcontrol(p, x) })

    # String Control
    str_controls <- lapply(xprs_getstringcontrols(),
                           function(x) { getstringcontrol(p, x) })

    # Fix Global Variables
    xpress::fixmipentities(prob = p, options = 0)

    # Rerun Problem As Linear Model For Sensitivity Analysis
    xpress::lpoptimize(p)
    
    # Extract LP Solution
    lp_solution <- xpress::getlpsol(prob = p)

    # Extract Sensitivity Ranges
    obj_sensitivity <- xpress::objsa(p, 1:model$column_count)
    bnd_sensitivity <- xpress::bndsa(p, 1:model$column_count)
    rhs_sensitivy <- xpress::rhssa(prob = p, rowind = 0:((constraints$rhs |> length())-1))
  
    # Calculate Reduced Costs
    reduced_cost_function <- xpress::calcreducedcosts(prob = p, 
                                             duals = lp_solution$duals,
                                             solution = lp_solution$x)
    
    # Create Solution List
    xpress_solution <- ompr::new_solution(model = model,
                                          objective_value = dbl_attributes$OBJVAL,
                                          status = 'optimal',
                                          solution = xpress_results,
                                          additional_solver_output = list(obj_sensitivity = obj_sensitivity,
                                                                          bnd_sensitivity = bnd_sensitivity,
                                                                          rhs_sensitivity = rhs_sensitivy,
                                                                          reduced_costs = reduced_cost,
                                                                          xpress_problem = p))
    
    # (int_attributes$MIPSTATUS |> get_xpress_status())
    
    # Return Solution
    return(xpress_solution)

  }

}

```

```{r}

model |> solve_model(xpress_optimizer(TIMELIMIT = 60, 
                                      MAXMIP = 1, 
                                      RANDOMSEED = 0))

```
