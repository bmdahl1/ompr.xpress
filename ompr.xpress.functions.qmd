---
---
title: "ompr.xpress package functions"
author: "Brandon Dahl"
format: html
editor: visual
---

## Import Libraries

To do:

1.  \#'\# To Do List \#' \#' Pre Model Run \#' Convert Upper And Lower Bounds Passing Into Algorithm \#' Create Conversion For All Model Parameter Settings \#' Check Whether Parameter \#' Create Function To Create Call To Xpress Model \#' \#' Post Model \#' Extract All Model Parameters \#' Return All Parameters In List \#' Ensure Parameters Are Available in OMPR model functionspass in solution
2.  label duals and reduced costs
3.  create test
4.  if original problem is linear, then skip the process of running the mixed integer solver
5.  dealing with infeasible solution

\#'\# To Do List \#' \#' Pre Model Run \#' Convert Upper And Lower Bounds Passing Into Algorithm \#' Create Conversion For All Model Parameter Settings \#' Check Whether Parameter \#' Create Function To Create Call To Xpress Model \#' \#' Post Model \#' Extract All Model Parameters \#' Return All Parameters In List \#' Ensure Parameters Are Available in OMPR model functions

```{r}

# Import Libraries
library(ompr)
library(xpress)
library(dplyr)
library(tidyr)

# Clear Out Variables
rm(list = ls())

```

## Test Optimization Problem

```{r}
#| include: false 

# Set Static Variables
ndays <- 5
nhours <- 24
per <- ndays * nhours

# Set Storage Values
in_storage <- 10
hourly_inflow <- 35
hourly_ifr <- 1
storage_max <- 300
storage_min <- 0

# Set PH Parameters
gen_segs <- 3
nrz_min <- 10
nrz_max <- 18
ph_pmin <- 6
ph_pmax <- 32
ph_starts <- 2

# Create Reservoir Parameters
res_parameters <- data.frame(HOUR = 1:per,
                             RES_MIN = rep(storage_min, per),
                             RES_MAX = rep(storage_max, per),
                             INFLOW = rep(hourly_inflow, per),
                             IFR = rep(hourly_ifr, per))

# Create Unit Parameters
unit_parameters <- data.frame(HOUR = 1:per,
                              MIN_LOAD = rep(6,per),
                              PMIN = rep(0,per),
                              PMAX = rep(32,per))

# Adjust Availability
# unit_parameters <- unit_parameters |>
#   mutate(PMAX = if_else(row_number()>= 100, 0, PMAX))

# PH WD Segments
unit_wd <- data.frame(MW_SEG = c(17.86, 11.14, 4),
                      SLOPE = c(2.26, 2.44, 2.71))

# Leakage
leakage <- 7.21

# Create Price Forecast
price <- data.frame(HOUR = 1:per,
                    PRICE = rep(c(62.29,58.00,55.70,55.46,55.70,
                              56.83,55.46,52.43,47.69,46.20,
                              47.78,49.29,49.88,52.62,54.64,
                              54.82,59.85,62.95,78.40,108.64,
                              87.62,72.74,71.54,65.69),ndays))

#_________________________________________________________________________________________________________
#### Build Optimization Model ####

# Create Model
model <- ompr::MIPModel()

#_______________________________________________________
##### Model - Create Decision Variables ####

# Create Decision Variables
model <- model |>
  # Create Gen Variables
  add_variable(gen[p], type = 'continuous', p = 1:per, lb = 0) |>
  add_variable(flow[p], type = 'continuous', p = 1:per, lb = 0) |>
  # Create Semi-Continuous Variable
  add_variable(gen_semcont_bin[p], type = 'binary', p=1:per) |>
  # Create Piecewise Gen Variables
  add_variable(gen_seg_enf[p,g], type = 'binary', p = 1:per, g = 1:gen_segs, lb = 0) |>
  add_variable(gen_segs[p,g], type = 'continuous', p = 1:per, g = 1:gen_segs, lb = 0) |>
  # Create No-Run Zone Variables
  add_variable(nrz_bin_one[p], type = 'binary', p = 1:per) |>
  add_variable(nrz_bin_two[p], type = 'binary', p = 1:per) |>
  add_variable(gen_stage_one[p], type = 'continuous', p = 1:per, lb = 0) |>
  add_variable(gen_stage_two[p], type = 'continuous', p = 1:per, lb = 0) |>
  # Create Reservoir Variables
  add_variable(storage[p], type = 'continuous', p = 1:per, lb = 0)

#_______________________________________________________
##### Model - Create Constraints ####

# Create Model Constraints
model <- model |>
  # Add Generation Constraints
  add_constraint(gen[p] <= unit_parameters$PMAX[p], p = 1:per) |>
  add_constraint(gen[p] >= unit_parameters$PMIN[p] , p = 1:per, lb = 0) |>
  # Add Semi-Continous Constraints
  add_constraint(gen[p] <= gen_semcont_bin[p]*unit_parameters$PMAX[p], p = 1:per) |>
  add_constraint(gen[p] >= gen_semcont_bin[p]*unit_parameters$MIN_LOAD[p], p = 1:per) |>
  # Add Piecewise Generation Constraints
  add_constraint(sum_over(gen_segs[p,g], g = 1:nrow(unit_wd)) == gen[p], p = 1:per) |>
  add_constraint(gen_segs[p,g] <= unit_wd$MW_SEG[g]*gen_seg_enf[p,g], p = 1:per, g = 1:3) |>
  add_constraint(gen_seg_enf[p,g] >= gen_seg_enf[p,g+1], p = 1:per, g = 1:(3-1)) |>
  add_constraint(gen_segs[p,g] >= unit_wd$MW_SEG[g]*gen_seg_enf[p,g+1], p = 1:per, g = 1:(3-1)) |>
  add_constraint(gen[p] >= gen_seg_enf[p,1]*1, p = 1:per) |>
  # Add No-Run Zone Constraints
  add_constraint(gen_stage_one[p] <= (nrz_min - ph_pmin)*nrz_bin_one[p], p = 1:per) |>
  add_constraint(gen_stage_two[p] <= (unit_parameters$PMAX[p] - nrz_max)*nrz_bin_two[p], p = 1:per) |>
  add_constraint(nrz_bin_one[p] >= nrz_bin_two[p], p = 1:per) |>
  add_constraint(gen_stage_one[p] >= (nrz_min - ph_pmin)*nrz_bin_two[p], p = 1:per) |>
  # Apply NRZ Constraint
  add_constraint(gen[p] == (ph_pmin*nrz_bin_one[p] + gen_stage_one[p] + ((nrz_max - nrz_min)*nrz_bin_two[p] + gen_stage_two[p])),
                 p = 1:per) |>
  # Create Flow Equations
  add_constraint((sum_over(gen_segs[p,g]*unit_wd$SLOPE[g], g = 1:3) + leakage*gen_seg_enf[p,1]) == flow[p], p = 1:per) |>
  # Create Reservoir Storage Constraints
  add_constraint(storage[p] == in_storage + hourly_inflow - hourly_ifr - flow[p], p = 1) |>
  add_constraint(storage[p] == storage[p-1] + hourly_inflow - hourly_ifr - flow[p], p = 2:per) |>
  add_constraint(storage[p] >= res_parameters$RES_MIN[p], p = 1:per) |>
  add_constraint(storage[p] <= res_parameters$RES_MAX[p], p = 1:per)

#_______________________________________________________
##### Model - Create Objective Function ####

  # Create Objective Function
model <- model |>
  set_objective(sum_over(gen[p]*price$PRICE[p], p = 1:per))

```

#### Extract Xpress Status

```{r}

get_xpress_status <- function(x){

  # Calculate Status
  temp_status <- switch(as.character(x),
                 "0" = "XPRS_MIP_NOT_LOADED",
                 "1" = "XPRS_MIP_LP_NOT_OPTIMAL",
                 "2" = "XPRS_MIP_LP_OPTIMAL",
                 "3" = "XPRS_MIP_NO_SOL_FOUND",
                 "4" = "XPRS_MIP_SOLUTION",
                 "5" = "XPRS_MIP_INFEAS",
                 "6" = "XPRS_MIP_OPTIMAL",
                 "7" = "XPRS_MIP_UNBOUNDED",
                 "error")

  # Return Status
  return(temp_status)

}


```

#### Extract OMPR Status

```{r}

# Get OMPR Status
get_ompr_status <- function(x){

  # Calculate Status
  temp_status <- switch(as.character(x),
                 "0" = "error",
                 "1" = "infeasible",
                 "2" = "optimal",
                 "3" = "infeasible",
                 "4" = "optimal",
                 "5" = "infeasible",
                 "6" = "optimal",
                 "7" = "unbounded",
                 "error")

  # Return Status
  return(temp_status)

}

```

#### Constraint Sense Conversion

```{r}

# Create Row Type Conversion
xpress_sense_conversion <- function(sense){

  # Create Conversion Library
  conversion_list <- list("<=" = "L",
                          "==" = "E",
                          ">=" = "G")

  # Convert Sense
  if (sense %in% names(conversion_list)){

    # Convert Symbol
    temp_sense <- conversion_list[[sense]]

    # Close Function
    return(temp_sense)

  } else {

    # Notify user
    paste0("The sense type ", sense, 
           ' is not a valid option. Check Xpress/OMPR documentation for assitance') |> 
      print()

  }
  
}

```

#### Column Type Conversion

```{r}

# Create Column Type Conversion
xpress_col_type_conversion <- function(col_type){

  # Create Conversion Library
  # Semi-Continuous not available in OMPR package, but included regardless
  conversion_list <- list('continuous' = 'C',
                          'binary' = 'B',
                          'integer' = 'I',
                          'semi-continuous' = 'S')

  # Convert Column Type
  if (col_type %in% names(conversion_list)){

    # Convert
    temp_col_type <- conversion_list[[col_type]]

    # Close Function
    return(temp_col_type)

  } else {

    # Notify user
    print(paste0('Column type ', col_type, 
                 '  does not exist. Explore OMPR/Xpress documentation for help troubleshooting'))

  }

}

```

#### Column Type Fill Function

```{r}

# Fill In Columns With Conversion
xpress_col_type_fill <- function(x, conversion_list){

  # Extract Data
  key <- sub(pattern = "\\[.*", "", x)

  # Check List
   if (key %in% names(conversion_list)){

     # Get Type
     temp_type <- conversion_list[[key]]
     return(temp_type)
   }

  # Print
  paste0('The column type ', key, 
         ' is not a valid option. Please explore Xpress/OMPR documentation for assistance') |> 
    print()

}

```

#### Apply All Control Parameters

```{r}

xpress_apply_control_params <- function(prob, control_params){
  
  # Get list of all control params
  xpress_control_params <- c(lapply(X = xprs_getintcontrols(), FUN = \(x) x <- 'integer'),
                             lapply(X = xprs_getdoublecontrols(), FUN = \(x) x <- 'double'),
                             lapply(X = xprs_getstringcontrols(), FUN = \(x) x <- 'string'))
  
  # Filter Control List
  filtered_x <- control_params[names(control_params) %in% names(xpress_control_params)]
  
  # Apply Controls
  if (length(filtered_x > 0)){
  
    # Classify Controls
    for (r in 1:length(filtered_x)){
      
      # Get Control Type, Parameter, Value
      control_type <- xpress_control_params[[filtered_x[r] |> names()]]
      control_parameter <- filtered_x[r] |> names()
      control_value <- filtered_x[r] |> unlist() |> unname()
      
      # Set Parameter
      if (control_type=='integer'){
        
        # Set Integer Parameter
        xpress::setintcontrol(prob = prob,
                              control = utils::getFromNamespace(control_parameter, "xpress"),
                              control_value |> as.integer())
        
      } else if(control_type == 'double'){
        
        # Set Double Parameter
        xpress::setdblcontrol(prob = prob,
                              control = utils::getFromNamespace(control_parameter, "xpress"),
                              control_value |> as.double())
        
      } else if(control_type == 'string'){
        
        # Set String Parameter
        xpress::setstrcontrol(prob = prob,
                              control = utils::getFromNamespace(control_parameter, "xpress"),
                              control_value |> as.character())
        
      }
      
    }
    
  }
  
}

```

#### Get All Control Parameters

```{r}

xpress_get_params <- function(prob){
  
  # Get Double Attributes
  dbl_attributes <- lapply(xprs_getdoubleattributes(),
                           function(x) { getdblattrib(prob, x) })
  
  # Get Integer Attritubes
  int_attributes <- lapply(xprs_getintattributes(),
                           function(x) { getintattrib(prob, x) })
  
  # Get String Attributes
  str_attributes <- lapply(xprs_getstringattributes(),
                            function(x) { getstringattrib(prob, x) })
  
  # Get Integer Controls
  int_controls <- lapply(xprs_getintcontrols(),
                          function(x) { getintcontrol(prob, x) })
  
  # Get Double Controls
  dbl_controls <- lapply(xprs_getdoublecontrols(),
                          function(x) { getdblcontrol(prob, x) })
  
  # String Control
  str_controls <- lapply(xprs_getstringcontrols(),
                          function(x) { getstringcontrol(prob, x) })
  
  # Create List
  param_list <- list(dbl_attributes = dbl_attributes,
                     int_attributes = int_attributes,
                     str_attributes = str_attributes,
                     int_controls = int_controls,
                     dbl_controls = dbl_controls,
                     str_controls = str_controls)
  
  return(param_list)
  
}

```

#### Perform Infeasibility Analysis

```{r}

run_inf_analysis <- function(prob){
  
  # Create Infeasability List
  inf_analysis <- list()
  
  # Get Integer Attributes from Presolve INdex
  get_inf_index <- xpress::getintattrib(prob = prob, attrib = xpress:::PRESOLVEINDEX)
  
  # Get Total Size of Problem
  tot_rows <- xpress::getintattrib(prob = prob, attrib = xpress:::ROWS)
  tot_spare_rows <- xpress::getintattrib(prob = prob, attrib = xpress:::SPAREROWS)
  tot_cols <- xpress::getintattrib(prob = prob, attrib = xpress:::COLS)
  
  # Check For Row or Columm Indice
  row_index_bool <- get_inf_index <= (tot_rows + tot_spare_rows)
  row_bool <- get_inf_index >= 1
  
  # Perform Presolve Infease Analysis
  if (all(row_index_bool,row_bool)){
  
    # Get Infeasible Row Data
    inf_row <- xpress::getrows(prob = prob, first = get_inf_index, last = get_inf_index)
        
    # Get Column Names
    inf_col_names <- sapply(X = inf_row$colind, 
                            FUN = \(x) xpress::getnamelist(prob = prob, first = x, last = x, type = 2))
    
    # Get Right Hand Side
    inf_row_rhs <- xpress::getrhs(prob = prob, first = get_inf_index, last = get_inf_index)
    
    # Set Initial Equation
    row_equation <- ''
    
    # Construct Equation
    for (w in 1:length(inf_col_names)){
      
      if (w == 1){
        
        # Build Column Variable
        col_var <- switch(inf_row$colcoef[w] |> as.character(),
                          '1' = inf_col_names[w],
                          '-1' = paste0(' - ', inf_col_names[w]),
                          paste0(inf_col_names[w]))
        
        } else {
          
          # Build Column Variable
          col_var <- switch(inf_row$colcoef[w] |> as.character(),
                            '1' = paste0(' + ', inf_col_names[w]),
                            '-1' = paste0(' - ', inf_col_names[w]),
                            paste0(inf_col_names[w]))
          
          }
          
      # Build Equation
      row_equation <- paste0(row_equation, col_var)
      
      }
    
    # Finish Equation
    inf_equation <- paste0(row_equation, ' = ', inf_row_rhs)
    
    # Create List 
    inf_analysis <- list(inf_row = inf_row,
                         inf_col_names = inf_col_names,
                         inf_row_rhw = inf_row_rhs)
  
  } else if(row_bool){
    
    # Get Column Index
    inf_col_index <- get_inf_index - (tot_rows + tot_spare_rows) - 1
    
    # Get Column Name
    inf_equation <- xpress::getname(prob = prob, first = inf_col_index, last = inf_col_index, type = 2)
    
    # Create List
    inf_analysis <- list(inf_col_index = inf_col_index)
  
  } else {
    
    # Set Null Data
    inf_analysis <- NA_character_
    inf_equation <- NA_character_
    
  }
  
  # Build List
  inf_list <- list(inf_index = get_inf_index,
                   inf_analysis = inf_analysis,
                   inf_equation = inf_equation)
  
  return(inf_list)
                  
}
  

```

#### Add MIP Solution

```{r}

add_mip_sol <- function(prob, heur_sol){
  
  # Get Column Count
  col_count <- xpress::getintattrib(prob, xpress:::COLS)
  
  # Get Column Names + Index
  name_index <- data.frame(COL_NAME = xpress::getnamelist(prob,2,0,col_count-1))
  
  # Add Column Number Index
  name_index['COL_INDEX'] <- (rownames(name_index) |> as.integer()) - 1
  
  # Add Index to Heur Solution DataFrame
  heur_sol_tot <- merge(x = heur_sol,
                        y = name_index,
                        by.x = 'Variable',
                        by.y = 'COL_NAME',
                        all.x = TRUE,
                        all.y = FALSE)
  
  # Extract Vectors
  solval <- heur_sol_tot$Value |> as.double()
  col_index <- heur_sol_tot$COL_INDEX |> as.integer()
  
  # Set Name
  name <- 'Heur_Sol'
  
  # Add MIP Sol
  if (length(col_index) < 0){
    
    xpress::addmipsol(prob = prob,
                      solval = solval,
                      colind = col_index,
                      name = name)
    
  }
  
}

```

### Optimize Function

```{r}

xpress_optimizer <- function(control = list(problem_name = 'Xpress Problem', verbose = TRUE,
                                            inf_analysis = TRUE), heur_sol = data.frame(), ...){

   # Check For Xpress Package
  if (!requireNamespace("xpress", quietly = TRUE)){

    # Notify IUser
    stop('You dont have the Xpress package installed')

  }

    # Create Model Run Function
  function(model){

    # Get All Control Parameters
    control <- c(control, ...)

    # Extract values from Model using OMPR functions
    obj <- ompr::objective_function(model)
    constraints <- ompr::extract_constraints(model)
    var_names <- ompr::variable_keys(model)
    upper_bounds <- ompr::variable_bounds(model)[['upper']]
    lower_bounds <- ompr::variable_bounds(model)[['lower']]
    col_types <- ompr::variable_types(model) |> as.character()
    obj_sense <- switch(model$objective$sense, 'max' = -1L, 'min' = 1L,
                        stop('Objective sense not valid'))

    # Create List For Xpress Problem Data
    problemdata <- list()

    # Create Objective Function
    problemdata$objcoef <- obj$solution |> as.numeric()

    # Get Row Coefficients
    problemdata$A <- constraints$matrix

    # Get Variable Types
    problemdata$columntypes <- sapply(col_types, xpress_col_type_conversion) |> unname()

    # Get problemdata Types
    problemdata$rowtype <- (lapply(X = constraints$sense, FUN = xpress_sense_conversion) |> unlist())

    # Get Right-Hand Side
    problemdata$rhs <- constraints$rhs |> as.numeric()

    # specify lower bounds and upper bounds for the columns
    problemdata$lb <- lower_bounds
    problemdata$ub <- upper_bounds

    # Add Variable Names
    problemdata$colname <- var_names

    # Name Problem
    problemdata$probname <- control$problem_name

    # Load Problem Into Xpress Prob Object
    p <- xpress::xprs_loadproblemdata(problemdata = problemdata)

    # Apply All Control Parameters
    xpress_apply_control_params(prob = p, control_params = control)

    # Set Problem Sense
    chgobjsense(p, obj_sense)

    # Set Output to Console
    if (control$verbose){setoutput(p)}
    
    # Add Presolution
    if (nrow(heur_sol) > 0){
      
      # Create MIP Soluiton
      add_mip_sol(prob = p,
                  heur_sol = heur_sol)
      
    }

    # Run Xpress Optimization
    summary(xpress::xprs_optimize(p))

    # Get Solution Status
    sol_status <- getintattrib(p, xpress:::MIPSTATUS) |> get_ompr_status()

    # Run If Feasible
    if (sol_status=='optimal'){

      # Extract Xpress Results
      xpress_results <- data.frame(Variable = problemdata$colname, Value = xprs_getsolution(p))

      # Get All Controls
      model_attributes <- xpress_get_params(prob = p)
      
      # Fix Global Variables
      xpress_verison <- packageVersion('xpress') |> as.character()
      if (compareVersion(xpress_verison |> as.character(),'9.2.5') >= 0){
        xpress::fixmipentities(prob = p, options = 0)
      } else {
        xpress::fixglobals(prob = p, options = 0)
      }

      # Rerun Problem As Linear Model For Sensitivity Analysis
      xpress::lpoptimize(p)

      # Extract LP Solution
      lp_solution <- xpress::getlpsol(prob = p)

      # Extract Sensitivity Ranges
      obj_sensitivity <- xpress::objsa(p, 0:(model_attributes$int_attributes$COLS-1))
      bnd_sensitivity <- xpress::bndsa(p, 0:(model_attributes$int_attributes$COLS-1))
      rhs_sensitivy <- xpress::rhssa(prob = p, rowind = 0:((constraints$rhs |> length())-1))

      # Add Variable Names to Sensitivity Ranges
      obj_sensitivity_df <- data.frame(Variable = xpress::getnamelist(p,2,0,(obj_sensitivity$lower |> length()-1)),
                                       lower = obj_sensitivity$lower,
                                       upper = obj_sensitivity$upper)
      bnd_sensitivity_df <- data.frame(Variable = xpress::getnamelist(p,2,0,(obj_sensitivity$lower |> length()-1)),
                                       lblower = bnd_sensitivity$lblower,
                                       lbupper = bnd_sensitivity$lbupper,
                                       ublower = bnd_sensitivity$ublower,
                                       ubupper = bnd_sensitivity$ubupper)

      # Get Reduced Costs
      reduced_costs <- data.frame(Variable = problemdata$colname,
                                  value = lp_solution$djs[1:(problemdata$colname |> length())])


      # Get Xpress Status
      xpress_status <- model_attributes$int_attributes$MIPSTATUS |> get_xpress_status()

    } else if (sol_status == 'infeasible' & control$inf_analysis){
      
      # Get All Controls
      model_attributes <- xpress_get_params(prob = p)

      # Perform Infeasibility Analysis
      inf_analysis <- run_inf_analysis(prob = p)
    }

    #__________________________________________________________________________________
    # Build Solution List

    if (sol_status == 'optimal'){

      # Create Solution List
      xpress_solution <- ompr::new_solution(model = model,
                                            objective_value = model_attributes$dbl_attributes$MIPOBJVAL,
                                            status = (model_attributes$int_attributes$MIPSTATUS |> get_ompr_status()),
                                            solution = xpress_results,
                                            additional_solver_output = list(obj_sensitivity = obj_sensitivity_df,
                                                                            bnd_sensitivity = bnd_sensitivity_df,
                                                                            rhs_sensitivity = rhs_sensitivy,
                                                                            reduced_costs = reduced_costs,
                                                                            model_attributes = model_attributes,
                                                                            lp_solution = lp_solution,
                                                                            xpress_status = xpress_status,
                                                                            xpress_problem = p))

    } else {

      # Create Empty Solution Set
      xpress_results <- data.frame(Variable = var_names,
                                   Value = 0)

      # Create Solution List
      xpress_solution <- ompr::new_solution(model = model,
                                            objective_value = Inf,
                                            status = xpress::getintattrib(p,xpress:::MIPSTATUS) |> get_ompr_status(),
                                            solution = xpress_results,
                                            additional_solver_output = list(inf_analysis = inf_analysis,
                                                                            model_attributes = model_attributes,
                                                                            xpress_problem = p))


    }

    return(xpress_solution)

  }

}

```

#### Test Run Model

```{r}

# Run Model
model_results <- model |> 
  solve_model(xpress_optimizer(MAXTIME = 60,
                               MIPRELSTOP = .0001,
                               TIMELIMIT = 10))

```

 

```{r}

 # iisall(p)
 #  status <- iisstatus(p)
 #  print(status)
 #  iis <- getiisdata(p, 1)
 #  print("IIS Data:")
 #  print(iis)

#     print(paste("Problem solved to status", getintattrib(p, xpress:::SOLSTATUS)))
#   
```
